/*
 * DO NOT MODIFY. THIS CODE IS MACHINE GENERATED BY THE TANNHÄUSER PD COMPILER.
 * THIS HEADER DEFINES THE INTERNAL TANNHÄUSER API.
 */

#ifndef _TANNBASE_H_
#define _TANNBASE_H_

#include "PdMessage.h"
#include "MessageQueue.h"
#include "Utils.h"

#define Base(_x) ((TannBase *) _x)

typedef struct TannBase {
	int numInputChannels;
	int numOutputChannels;
	int blockSize;
	double sampleRate;
	double blockStartTimestampMs;
	void (*f_scheduleMessageForReceiver)(struct TannBase *const, const char *, PdMessage *);
	struct MessageTable *(*f_getTableForName)(struct TannBase *const, const char *);
	MessageQueue mq;
	void (*printHook)(double, const char *, const char *);
	void (*sendHook)(const char *, PdMessage *);
	char *basePath;
	void *userData;
} TannBase;

/**
 * Returns the sample index at which this time takes place in the current block.
 * If the event takes place before the current block, the index is zero.
 */
static inline int ctx_getBlockIndexForTimestamp(TannBase *_c, double timestampMs) {
	return (timestampMs > _c->blockStartTimestampMs)
			? (int) ((timestampMs - _c->blockStartTimestampMs) * .001 * _c->sampleRate) : 0;
}

/**
 * Schedule a message in the message queue according to its timestamp. The copy of the message
 * added to the queue is returned.
 */
static inline PdMessage *ctx_scheduleMessage(TannBase *_c, PdMessage *m,
        void (*sendMessage)(TannBase *, int, PdMessage *), int outletIndex) {
	return mq_addMessageByTimestamp(&_c->mq, m, outletIndex, sendMessage);
}

static inline void ctx_scheduleMessageForReceiver(TannBase *const _c, const char *name, PdMessage *m) {
	_c->f_scheduleMessageForReceiver(_c, name, m);
}

void ctx_scheduleMessageForReceiverV(TannBase *const _c, const char *name, const double timestamp, const char *format, ...);

void ctx_cancelMessage(TannBase *_c, PdMessage *m);

static inline int ctx_millisecondsToSamples(TannBase *_c, float timeInMs) {
	return (int) (timeInMs * _c->sampleRate / 1000.0);
}

static inline double ctx_samplesToMilliseconds(TannBase *_c, int samples) {
	return 1000.0 * samples / _c->sampleRate;
}

/** Returns the nominal block size. */
static inline int ctx_getBlockSize(TannBase *_c) {
	return _c->blockSize;
}

static inline double ctx_getSampleRate(TannBase *_c) {
	return _c->sampleRate;
}

static inline int ctx_getNumInputChannels(TannBase *_c) {
	return _c->numInputChannels;
}

static inline int ctx_getNumOutputChannels(TannBase *_c) {
    return _c->numOutputChannels;
}

static inline void ctx_setPrintHook(TannBase *const _c, void (*f)(double, const char *, const char *)) {
    _c->printHook = f;
}

static inline void ctx_setSendHook(TannBase *const _c, void (*f)(const char *, PdMessage *m)) {
    _c->sendHook = f;
}

static inline void *ctx_getUserData(TannBase *const _c) {
    return _c->userData;
}

static inline void ctx_setUserData(TannBase *const _c, void *userData) {
    _c->userData = userData;
}

void ctx_setBasePath(TannBase *const _c, const char *basePath);

static inline const char *ctx_getBasePath(TannBase *const _c) {
    return _c->basePath;
}

static inline struct MessageTable *ctx_getTableForName(TannBase *const _c, const char *tableName) {
	return _c->f_getTableForName(_c, tableName);
}

#endif // _TANNBASE_H_
