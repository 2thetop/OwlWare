/*
 * DO NOT MODIFY. THIS CODE IS MACHINE GENERATED BY THE TANNHÃ„USER PD COMPILER.
 */

#import "THtann.h" // the objc header file
#include "Tannhauser_tann.h" // the C API
#include "MessageTable.h"

@interface THtann () {
	Tann_tann *context;
	NSLock *mu;
}
@end

@implementation THtann

static void tann_print(double timestamp, const char *name, const char *message) {
	NSLog(@"%.3f [%@@%s] %s", timestamp, @"Tann_tann", name, message);
}

- (id)initWithInputChannels:(NSInteger)numInputChannels outputChannels:(NSInteger)numOutputChannels
		blockSize:(NSInteger)blockSize sampleRate:(Float64)sampleRate andBasePath:(NSString *)basePath {
	self = [super init];
	if (self != nil) {
		mu = [[NSLock alloc] init];
		self->context = ctx_tann_new((int) numInputChannels, (int) numOutputChannels, (int) blockSize, sampleRate);
		ctx_setPrintHook(Base(self->context), &tann_print); // default printhook
		ctx_setUserData(Base(self->context), (__bridge void *) self);
		ctx_setBasePath(Base(self->context), [basePath cStringUsingEncoding:NSASCIIStringEncoding]);
	}
	return self;
}

- (void)dealloc {
	ctx_tann_free(self->context);
}

- (bool)sendMessageToReceiver:(NSString *)name atTime:(Float64)timestamp withFormatAndData:(NSString *)format, ... {
	va_list ap;
    va_start(ap, format);
	
	PdMessage *m = PD_MESSAGE_ON_STACK(format.length);
	msg_init(m, (int) format.length, timestamp);

	for (int i = 0; i < format.length; i++) {
		switch ([format characterAtIndex:i]) {
			case 'b': msg_setBang(m, i); break;
			case 'f': msg_setFloat(m, i, (Float32) va_arg(ap, Float64)); break;
			case 's': {
				NSString *str = (NSString *) va_arg(ap, NSString *);
				msg_setSymbol(m, i, (char *) [str cStringUsingEncoding:NSASCIIStringEncoding]);
				break;
			}
			default: return false;
		}
	}
	
	va_end(ap);
	
	[mu lock];
	ctx_scheduleMessageForReceiver(Base(self->context), [name cStringUsingEncoding:NSASCIIStringEncoding], m);
	[mu unlock];
	
	return true;
}

- (void)processWithInput:(Float32 *)inputBuffers output:(Float32 *)outputBuffers withBlockSize:(int)n {
	[mu lock];
	ctx_tann_process(self->context, inputBuffers, outputBuffers, n);
	[mu unlock];
}

- (void)processBlock:(void(^)())block {
	[mu lock];
	block();
	[mu unlock];
}

- (float *)getTableBufferForName:(NSString *)tableName withLength:(int *)length resize:(BOOL)resize {
	MessageTable *table = ctx_getTableForName(Base(self->context), [tableName cStringUsingEncoding:NSASCIIStringEncoding]);
	if (table != NULL) {
		if (resize) {
			[mu lock];
			mTable_resize(table, *length);
            [mu unlock];
		}
		if (length != NULL) *length = mTable_getLength(table);
		return mTable_getBuffer(table);
	} else {
		if (length != NULL) *length = 0;
		return NULL;
	}
}

- (void)lock {
	[mu lock];
}

- (void)unlock {
	[mu unlock];
}

@end
