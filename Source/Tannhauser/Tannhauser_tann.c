/*
 * DO NOT MODIFY. THIS CODE IS MACHINE GENERATED BY THE TANNHÃ„USER PD COMPILER.
 */

/*
 * System Includes
 */

#include <string.h>
#include <stdarg.h>
#include "Tannhauser_tann.h"



/*
 * Function Declarations
 */

static void mMsg_kcCqS_onMessage(TannBase *, PdMessage *);
static void mFloat_yd3Kz_sendMessage(TannBase *, int, PdMessage *);
static void mMsg_nXF4e_onMessage(TannBase *, PdMessage *);
static void mFloat_4jxjT_sendMessage(TannBase *, int, PdMessage *);
static void mMsg_2cB96_onMessage(TannBase *, PdMessage *);
static void mFloat_n5QY1_sendMessage(TannBase *, int, PdMessage *);
static void mMsg_lzghT_onMessage(TannBase *, PdMessage *);
static void mFloat_bfXtM_sendMessage(TannBase *, int, PdMessage *);
static void mRecv_6sIrH_onMessage(TannBase *, int, PdMessage *);
static void mRecv_aWQ6l_onMessage(TannBase *, int, PdMessage *);
static void mRecv_oCE96_onMessage(TannBase *, int, PdMessage *);
static void mRecv_AWNAP_onMessage(TannBase *, int, PdMessage *);



/*
 * Static Helper Functions
 */

static void ctx_intern_scheduleMessageForReceiver(TannBase *const _c, const char *name, PdMessage *m) {
    // the message must occur in the future, at least after the start of the current block
	msg_setTimestamp(m, fmax(msg_getTimestamp(m), _c->blockStartTimestampMs));
	
	if (!strncmp(name, "Channel-C", 9)) {
		ctx_scheduleMessage(Base(_c), m, &mRecv_oCE96_onMessage, 0);
		return;
	}
	if (!strncmp(name, "Channel-B", 9)) {
		ctx_scheduleMessage(Base(_c), m, &mRecv_aWQ6l_onMessage, 0);
		return;
	}
	if (!strncmp(name, "Channel-A", 9)) {
		ctx_scheduleMessage(Base(_c), m, &mRecv_6sIrH_onMessage, 0);
		return;
	}
	if (!strncmp(name, "Channel-D", 9)) {
		ctx_scheduleMessage(Base(_c), m, &mRecv_AWNAP_onMessage, 0);
		return;
	}
}

static struct MessageTable *ctx_intern_getTableForName(TannBase *const _c, const char *tableName) {
	
	return NULL; // by default, return NULL
}



/*
 * Context Include and Implementatons
 */

Tann_tann *ctx_tann_new(int numInputChannels, int numOutputChannels, int blockSize, double sampleRate) {
	Tann_tann *const _c = (Tann_tann *) malloc(sizeof(Tann_tann));

	Base(_c)->numInputChannels = numInputChannels;
	Base(_c)->numOutputChannels = numOutputChannels;
	Base(_c)->blockSize = blockSize;
	Base(_c)->sampleRate = sampleRate;
	Base(_c)->blockStartTimestampMs = 0.0;
	Base(_c)->f_scheduleMessageForReceiver = &ctx_intern_scheduleMessageForReceiver;
	Base(_c)->f_getTableForName = &ctx_intern_getTableForName;
	mq_init(&Base(_c)->mq);
	Base(_c)->basePath = NULL;
	Base(_c)->printHook = NULL;
	Base(_c)->sendHook = NULL;
	Base(_c)->userData = NULL;

	mFloat_init(&_c->mFloat_yd3Kz, 0.0f);
	dLine_init(&_c->dLine_lFWZE);
	mFloat_init(&_c->mFloat_4jxjT, 0.0f);
	dLine_init(&_c->dLine_iIF6Z);
	mFloat_init(&_c->mFloat_n5QY1, 0.0f);
	dLine_init(&_c->dLine_9a4RK);
	mFloat_init(&_c->mFloat_bfXtM, 0.0f);
	dLine_init(&_c->dLine_sqWoz);

	return _c;
}

void ctx_tann_free(Tann_tann *_c) {
	dLine_free(&_c->dLine_lFWZE);
	dLine_free(&_c->dLine_iIF6Z);
	dLine_free(&_c->dLine_9a4RK);
	dLine_free(&_c->dLine_sqWoz);

	free(Base(_c)->basePath);
	mq_free(&Base(_c)->mq); // free queue after all objects have been freed, messages may be cancelled

	free(_c);
}



/*
 * Static Function Implementation
 */

static void mMsg_kcCqS_onMessage(TannBase *_c, PdMessage *n) {
	PdMessage *m = NULL;

	// define messages and send them (all inlined)
	m = PD_MESSAGE_ON_STACK(2);
	msg_init(m, 2, msg_getTimestamp(n));
	msg_setElementToFrom(m, 0, n, 0);
	msg_setFloat(m, 1, 10.0f);
	dLine_onMessage(&Context(_c)->dLine_lFWZE, 0, m);
}

static void mFloat_yd3Kz_sendMessage(TannBase *_c, int letIndex, PdMessage *m) {
	mMsg_kcCqS_onMessage(_c, m);
}

static void mMsg_nXF4e_onMessage(TannBase *_c, PdMessage *n) {
	PdMessage *m = NULL;

	// define messages and send them (all inlined)
	m = PD_MESSAGE_ON_STACK(2);
	msg_init(m, 2, msg_getTimestamp(n));
	msg_setElementToFrom(m, 0, n, 0);
	msg_setFloat(m, 1, 10.0f);
	dLine_onMessage(&Context(_c)->dLine_iIF6Z, 0, m);
}

static void mFloat_4jxjT_sendMessage(TannBase *_c, int letIndex, PdMessage *m) {
	mMsg_nXF4e_onMessage(_c, m);
}

static void mMsg_2cB96_onMessage(TannBase *_c, PdMessage *n) {
	PdMessage *m = NULL;

	// define messages and send them (all inlined)
	m = PD_MESSAGE_ON_STACK(2);
	msg_init(m, 2, msg_getTimestamp(n));
	msg_setElementToFrom(m, 0, n, 0);
	msg_setFloat(m, 1, 10.0f);
	dLine_onMessage(&Context(_c)->dLine_9a4RK, 0, m);
}

static void mFloat_n5QY1_sendMessage(TannBase *_c, int letIndex, PdMessage *m) {
	mMsg_2cB96_onMessage(_c, m);
}

static void mMsg_lzghT_onMessage(TannBase *_c, PdMessage *n) {
	PdMessage *m = NULL;

	// define messages and send them (all inlined)
	m = PD_MESSAGE_ON_STACK(2);
	msg_init(m, 2, msg_getTimestamp(n));
	msg_setElementToFrom(m, 0, n, 0);
	msg_setFloat(m, 1, 10.0f);
	dLine_onMessage(&Context(_c)->dLine_sqWoz, 0, m);
}

static void mFloat_bfXtM_sendMessage(TannBase *_c, int letIndex, PdMessage *m) {
	mMsg_lzghT_onMessage(_c, m);
}

static void mRecv_6sIrH_onMessage(TannBase *_c, int inletIndex, PdMessage *m) {
	mMsg_kcCqS_onMessage(_c, m);
}

static void mRecv_aWQ6l_onMessage(TannBase *_c, int inletIndex, PdMessage *m) {
	mMsg_nXF4e_onMessage(_c, m);
}

static void mRecv_oCE96_onMessage(TannBase *_c, int inletIndex, PdMessage *m) {
	mMsg_2cB96_onMessage(_c, m);
}

static void mRecv_AWNAP_onMessage(TannBase *_c, int inletIndex, PdMessage *m) {
	mMsg_lzghT_onMessage(_c, m);
}



/*
 * Context Process Implementation
 */

void ctx_tann_process(Tann_tann *const _c, float *const inputBuffers, float *const outputBuffers, const int n) {

	// process all of the messages for this block
	const double nextBlockStartTimestampMs = Base(_c)->blockStartTimestampMs + (1000.0*n/ctx_getSampleRate(Base(_c)));
	while (mq_hasMessageBefore(&Base(_c)->mq, nextBlockStartTimestampMs)) {
		MessageNode *const node = mq_peek(&Base(_c)->mq);
		node->sendMessage(Base(_c), node->let, node->m);
		mq_pop(&Base(_c)->mq);
	}

	// define a macro to refer to input buffers
	#define I(_x) (inputBuffers+((_x)*n))

	// define a macro to refer to output buffers
	#define O(_x) (outputBuffers+((_x)*n))
    utils_clearBuffer(outputBuffers, ctx_getNumOutputChannels(Base(_c))*n); // clear the output buffer

	// define the zero buffer
	float ZERO_BUFFER[n];
	utils_clearBuffer(ZERO_BUFFER, n);

	// initialise temporary signal buffers
	#define B(_x) (buffer+((_x)*n))
	float buffer[3 * n];

    float z=inputBuffers[2];
	// process all signal functions
	dLine_processM(Base(_c), &_c->dLine_lFWZE, B(0), n); // line~
	dMult_processSS(B(0), I(0), B(0), n); // *~
	dLine_processM(Base(_c), &_c->dLine_9a4RK, B(1), n); // line~
	dMult_processSS(B(1), I(1), B(1), n); // *~
	dAdd_processSS(B(0), B(1), B(1), n); // +~
	dLine_processM(Base(_c), &_c->dLine_iIF6Z, B(0), n); // line~
	dMult_processSS(B(0), I(0), B(0), n); // *~
	dLine_processM(Base(_c), &_c->dLine_sqWoz, B(2), n); // line~
	dMult_processSS(B(2), I(1), B(2), n); // *~
	dAdd_processSS(B(0), B(2), B(2), n); // +~
	dAdd_processSS(B(1), O(0), O(0), n); // dac~(0)
	dAdd_processSS(B(2), O(1), O(1), n); // dac~(1)

	// now that the block has been processed, update the block timestamp
	Base(_c)->blockStartTimestampMs = nextBlockStartTimestampMs;
}
