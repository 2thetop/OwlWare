/*
 * DO NOT MODIFY. THIS CODE IS MACHINE GENERATED BY THE TANNHÄUSER PD COMPILER.
 * THIS HEADER DEFINES THE EXTERNAL TANNHÄUSER API.
 */

#pragma mark - Tannhäuser Table

#ifndef _TANNHAUSER_TABLE_H_
#define _TANNHAUSER_TABLE_H_

typedef struct PdTable PdTable;

/**
 * Resizes the table to the given length. Length must be positive.
 * Existing contents are copied to the new table. Remaining space is cleared.
 */
void th_table_resize(PdTable *o, int newLength);

/** Returns a pointer to the raw buffer backing this table. DO NOT free it. */
float *th_table_getBuffer(PdTable *o);

/** Returns the length of this table in samples. */
int th_table_getLength(PdTable *o);

#endif // _TANNHAUSER_TABLE_H_



#pragma mark - Tannhäuser Message

#ifndef _TANNHAUSER_MESSAGE_H_
#define _TANNHAUSER_MESSAGE_H_

#include <stdbool.h>

typedef struct PdMessage PdMessage;

/** Returns the number of elements in this message. */
int th_msg_getNumElements(PdMessage *m);

/** Returns the time at which this message exists (in milliseconds). */
double th_msg_getTimestamp(PdMessage *m);

/** Set the time at which this message should be executed (in milliseconds). */
void th_msg_setTimestamp(PdMessage *m, double timestamp);

/** Returns true of the indexed element is a bang. False otherwise. Index is not bounds checked. */
bool th_msg_isBang(PdMessage *m, int i);

/** Sets the indexed element to a bang. Index is not bounds checked. */
void th_msg_setBang(PdMessage *m, int i);

/** Returns true of the indexed element is a float. False otherwise. Index is not bounds checked. */
bool th_msg_isFloat(PdMessage *m, int i);

/** Returns the indexed element as a float value. Index is not bounds checked. */
float th_msg_getFloat(PdMessage *m, int i);

/** Sets the indexed element to float value. Index is not bounds checked. */
void th_msg_setFloat(PdMessage *m, int i, float f);

/** Returns true of the indexed element is a symbol. False otherwise. Index is not bounds checked. */
bool th_msg_isSymbol(PdMessage *m, int i);

/** Returns the indexed element as a symbol value. Index is not bounds checked. */
char *th_msg_getSymbol(PdMessage *m, int i);

/** Sets the indexed element to symbol value. Index is not bounds checked. */
void th_msg_setSymbol(PdMessage *m, int i, const char *s);

/**
  * Returns true if the message has the given format, in number of elements and type. False otherwise.
  * Valid element types are:
  * 'b': bang
  * 'f': float
  * 's': symbol
  *
  * For example, a message with three floats would have a format of "fff". A single bang is "b".
  * A message with two symbols is "ss". These types can be mixed and matched in any way.
  */
bool th_msg_hasFormat(PdMessage *m, const char *fmt);

/**
 * Returns a basic string representation of the message.
 * The character array MUST be deallocated by the caller.
 */
char *th_msg_toString(PdMessage *msg);

/** Copy a message onto the stack. The message persists. */
PdMessage *th_msg_copy(PdMessage *m);

/** Free a copied message. */
void th_msg_free(PdMessage *m);

#endif // _TANNHAUSER_PDMESSAGE_H_



#pragma mark - Tannhäuser Tann Patch

#ifndef _TANNHAUSER_TANN_H_
#define _TANNHAUSER_TANN_H_

typedef struct Tann_tann Tann_tann;

/**
 * Creates a new patch instance. Block size should be a power of two. Sample rate should be positive and in Hertz.
 * Input and output channels should be non-negative.
 */
Tann_tann *th_tann_new(int numInputChannels, int numOutputChannels, int blockSize, double sampleRate);

/** Frees a patch instance. */
void th_tann_free(Tann_tann *c);

/** Processes one block of samples for a patch instance. */
void th_tann_process(Tann_tann *c, float *inputBuffers, float *outputBuffer);

#endif // _TANNHAUSER_TANN_H_



#pragma mark - Tannhäuser Common

#ifndef _TANNHAUSER_COMMON_H_
#define _TANNHAUSER_COMMON_H_

typedef void Tannhauser;

/** Returns the block size with which this patch has been configured. */
int th_getBlockSize(Tannhauser *c);

/** Returns the sample rate with which this patch has been configured. */
double th_getSampleRate(Tannhauser *c);

/** Returns the number of input channels with which this patch has been configured. */
int th_getNumInputChannels(Tannhauser *c);

/** Returns the number of output channels with which this patch has been configured. */
int th_getNumOutputChannels(Tannhauser *c);

/** Set the print hook. The function is called whenever a message is sent to a print object. */
void th_setPrintHook(Tannhauser *c, void (*f)(double timestamp, const char *printName, const char *message));

/**
  * Set the send hook. The function is called whenever a message is sent to any send object.
  * Messages returned by this function should NEVER be freed. If the message must persist, call
  * th_msg_copy() first.
  */
void th_setSendHook(Tannhauser *c, void (*f)(const char *receiverName, PdMessage *m));

void th_vscheduleMessageForReceiver(Tannhauser *c, const char *receiverName, double timestamp, const char *format, ...);

/** Cancels a previously scheduled message. */
void th_cancelMessage(Tannhauser *c, PdMessage *m);

/** Returns a table object given its name. NULL if no table with that name exists. */
PdTable *th_getTableForName(Tannhauser *c, const char *tableName);

/** Returns the current patch time in milliseconds. */
double th_getCurrentTime(Tannhauser *c);

/** Sets a user-definable value. This value is never manipulated by Tannhäuser. */
void th_setUserData(Tannhauser *c, void *userData);

/** Returns the user-defined data. */
void *th_getUserData(Tannhauser *c);

#endif // _TANNHAUSER_COMMON_H_
